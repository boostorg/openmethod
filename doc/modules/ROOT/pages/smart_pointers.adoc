
## Smart Pointers

If we want maximum performance, we want to use `virtual_ptr`{empty}s in place of
ordinary pointers or references. However, many designs want to use smart
pointers for lifetime management; think of `std::unique_ptr`, `std::shared_ptr`,
or `boost::intrusive_ptr`.

Does it mean that we have to choose between the performance of `virtual_ptr` and
the convenience of `std::unique_ptr`? Or carry around both types of smart
pointers? Fortunately, no. `virtual_ptr` can inter-operate with smart pointers.

If `virtual_ptr` recognizes that its template argument is a smart pointer class,
it uses that smart pointer to track the underlying object, instead of a plain
pointer. `virtual_ptr<const Node>` and `virtual_ptr<std::unique_ptr<const
Node>>` both point to a `const Node`; the former uses a plain `const Node*`
while the latter uses a `std::unique_ptr<const Node>`. Both carry the same
v-table pointer.

Smart `virtual_ptr`{empty}'s automatically convert to their non-smart, "plain"
counterparts - e.g. from `virtual_ptr<std::unique_ptr<const Node>>` to
`virtual_ptr<const Node>`. Methods and overriders typically use plain
`virtual_ptr`{empty}'s, although it is not always the case. For example,
consider a `transpose` method for matrices. If the matrix is symmetric, the
overrider should return its argument. This can be implemented by passing a `virtual_ptr<std::shared_ptr<const Matrix>>` to the method.

The reverse conversion, from plain to smart, does not exist, because it would be
unsafe.

A smart `virtual_ptr` can be constructed from a corresponding smart pointer, but
not directly from a plain reference or pointer, because it has the potential to
accidentally create smart pointers.

Here is a variation of the AST example that uses dynamic allocation and unique
pointers:

[source,c++]
----
include::example$ast_unique_ptr.cpp[tag=content]
----
