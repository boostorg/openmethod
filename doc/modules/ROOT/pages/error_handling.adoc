
## Error Handling

When an error is encountered, the program is terminated by a call to `abort`. If
the registry contains an `error_handler` policy, it provides an `error` member
function (or overloaded functions) to be called with an object identifying the
error. `release_registry` and `debug_registry` implement the error policy with
`default_error_handler`, which wraps the error object in a variant, and calls a
handler via a `std::function`. By default, it prints a description of the error
to `stderr`, but this can be changed, for example, to throw an exception:

[source,c++]
----
include::example$default_error_handler.cpp[tag=example]
----

Output:

[source,console]
----
spin
not implemented
spin
----

We can also replace the `error_handler` policy with our own. For example:


[source,c++]
----
include::example$throw_error_handler.cpp[tag=example]
----

[source,console]
----
spin
not implemented
spin
----

Stock policy `throw_error_handler` does this for all the error types:

```c++
namespace boost::openmethod::policies {

struct throw_error_handler : error_handler {
    template<class Error>
    [[noreturn]] static auto error(const Error& error) -> void {
        throw error;
    }
};

} // namespace boost::openmethod::policies
```
